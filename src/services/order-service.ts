// This is an autogenerated file from Firebase Studio.
"use client";

import {
  collection,
  addDoc,
  getDocs,
  deleteDoc,
  doc,
  getDoc,
  query,
  orderBy,
  onSnapshot,
  Unsubscribe,
  serverTimestamp,
  Timestamp,
  updateDoc,
  where,
} from "firebase/firestore";
import { db } from "../lib/firebase";
import { type Order, type OrderStatus } from "../types";

const ORDERS_COLLECTION = "orders";

export const listenToOrders = (callback: (orders: Order[]) => void): Unsubscribe => {
  const q = query(collection(db, ORDERS_COLLECTION), orderBy("createdAt", "desc"));
  const unsubscribe = onSnapshot(q, (querySnapshot) => {
    const orders: Order[] = [];
    querySnapshot.forEach((doc) => {
       const data = doc.data();
      // Ensure createdAt is a Firebase Timestamp, then convert to Date for the client if needed.
      // For now, we'll keep it as a Timestamp and convert on the component side.
      orders.push({ 
        id: doc.id,
        ...data,
        createdAt: data.createdAt, // This should be a Timestamp
        completedAt: data.completedAt,
      } as Order);
    });
    callback(orders);
  }, (error) => {
    console.error("Error listening to orders: ", error);
    callback([]);
  });
  return unsubscribe;
};

export const listenToOrdersByStatus = (status: OrderStatus, callback: (orders: Order[]) => void): Unsubscribe => {
    const q = query(
        collection(db, ORDERS_COLLECTION), 
        where("status", "==", status)
        // orderBy("createdAt", "desc") // This requires a composite index. Removing it and sorting on client.
    );
     const unsubscribe = onSnapshot(q, (querySnapshot) => {
        const orders: Order[] = [];
        querySnapshot.forEach((doc) => {
            const data = doc.data();
            orders.push({ 
                id: doc.id,
                ...data,
                createdAt: data.createdAt,
                completedAt: data.completedAt
            } as Order);
        });
        // Sort on the client side
        orders.sort((a, b) => (b.createdAt?.toMillis() || 0) - (a.createdAt?.toMillis() || 0));
        callback(orders);
    }, (error) => {
        console.error(`Error listening to orders with status ${status}: `, error);
        callback([]);
    });

    return unsubscribe;
}

export const listenToOrdersWithCoupon = (callback: (orders: Order[]) => void): Unsubscribe => {
  const q = query(
    collection(db, ORDERS_COLLECTION), 
    where("coupon", "!=", null),
    orderBy("createdAt", "desc")
  );
  const unsubscribe = onSnapshot(q, (querySnapshot) => {
    const orders: Order[] = [];
    querySnapshot.forEach((doc) => {
      const data = doc.data();
      orders.push({ 
        id: doc.id,
        ...data,
        createdAt: data.createdAt,
        completedAt: data.completedAt,
      } as Order);
    });
    callback(orders);
  }, (error) => {
    console.error("Error listening to orders with coupon: ", error);
    callback([]);
  });
  return unsubscribe;
}


export const listenToOrdersByUserId = (userId: string, callback: (orders: Order[]) => void): Unsubscribe => {
    const q = query(
        collection(db, ORDERS_COLLECTION), 
        where("userId", "==", userId),
        orderBy("createdAt", "desc")
    );
     const unsubscribe = onSnapshot(q, (querySnapshot) => {
        const orders: Order[] = [];
        querySnapshot.forEach((doc) => {
            const data = doc.data();
            orders.push({ 
                id: doc.id,
                ...data,
                createdAt: data.createdAt,
                completedAt: data.completedAt,
            } as Order);
        });
        callback(orders);
    }, (error) => {
        console.error("Error listening to user orders: ", error);
        callback([]);
    });

    return unsubscribe;
}

export const addOrder = async (
  order: Omit<Order, "id">
): Promise<string | null> => {
  try {
    const docRef = await addDoc(collection(db, ORDERS_COLLECTION), {
      ...order,
      createdAt: serverTimestamp() // Use server timestamp for consistency
    });
    console.log("Order added with ID: ", docRef.id);
    return docRef.id;
  } catch (error) {
    console.error("Error adding order: ", error);
    return null;
  }
};

export const updateOrderStatus = async (orderId: string, status: OrderStatus): Promise<Order | null> => {
    try {
        const orderRef = doc(db, ORDERS_COLLECTION, orderId);
        
        const updateData: {status: OrderStatus, completedAt?: any} = { status: status };
        if (status === "Conclu√≠do") {
            updateData.completedAt = serverTimestamp();
        }

        await updateDoc(orderRef, updateData);

        const updatedDoc = await getDoc(orderRef);
        if (updatedDoc.exists()) {
            const data = updatedDoc.data();
            return { 
                id: updatedDoc.id, 
                ...data,
                createdAt: data.createdAt,
                completedAt: data.completedAt,
             } as Order;
        }
        return null;
    } catch (error) {
        console.error("Error updating order status: ", error);
        return null;
    }
}

export const deleteOrder = async (orderId: string): Promise<boolean> => {
    try {
        const orderRef = doc(db, ORDERS_COLLECTION, orderId);
        await deleteDoc(orderRef);
        return true;
    } catch (error) {
        console.error("Error deleting order: ", error);
        return false;
    }
}
